<br>

# 프로그래밍의 이해와 개발환경 구축

나열 = 순서대로

#컴파일 (C언어-기계어(2진수)) = 번역<br>
#디버깅 = 오류찾기

라이브러리 - 링크 - 이미 만들어진 기능을 연결한다

* 코드작성 -> .C <br>
* 컴파일 -> .obj <br>
* 링크 -> .exe(실행파일)<br>
<br>
<br>
<br>

# 변수와 자료형

#변수의 사용 목적

1. 간편한 수정<br>
2. 값에 의미부여<br>
3. 다음 명령에서의 기억<br>

unsigned = 부호가 없는 -> 0부터 시작

#변수명 주의사항<br>
* 영문, 숫자, _<br>
* 숫자로 시작X<br>
* 대소문자 구분<br>
* 키워드 사용X<br>

<카멜표기법><br>
homeaddress -> homeAddress<br>
-실수형 = %f

<아스키코드표><br>
* A = 65 (1씩 증가..)<br>
* a = 97 (1씩 증가...)
<br>
<br>
<br>

# 상수와 키워드

리터널 상수 = 값 자체가 고정된 값<br>
심볼링 상수 = 값에 의미있는 이름을 붙여 사용<br>
> (const 자료형 변수명 = 값;) = 변수를 값으로 고정시킨다->상수화 시킨다<br>
 > (#define 변수명 값(수식)) = 변수를 값으로 정의한다

#차이점
- const (심볼링 상수) - 실행이 될때 상수로 고정
- #define (사용자정의 상수) - 실행 전에 처리(전처리기)

#유사점<br>
- 변경하지 않게 만들겠다
- 키워드 = 이미 뜻이 있고, 사용하고 있는 단어
<br>
<br>
<br>


# 출력 함수

#형식지정자 (%d %s..)<br>
printf 에서는 %f , %lf 구분X<br>
문자열은 기본출력 가능 || %s 사용 가능<br>

#제어문자<br>
* \t = 탭 만큼 띄어쓰기
* \n = 줄바꿈
* \0 = 공백문자

%[자릿수][형식지정자]<br>
  %10d ->
 오른쪽 정렬 _ _ _ _ _ 1 2 3 4 5<br>
  %-10d  ->
왼쪽정렬 1 2 3 4 5 _ _ _ _ _<br>
<br>
<br>
<br>


# 입력 함수

scanf -> f = 포맷<br>
자릿수 : 생략가능<br>
float = %f / double = %lf<br>
& = 주소<br>
- 형식지정자 사이에는 공백만 가능<br>
(%d %d)->O // (%d, %d)->X

scanf_s("형식지정자",&변수명,크기)<br>
  1. sizeof(int) 4byte
  2. sizeof(double) 8byte
  3. sizeof(char) 1byte
<br>
<br>
<br>

# 기타입출력 함수

#getchar #putchar<br>
- 문자 하나만 입출력<br>
- 출력시 putchar 사용 (getchar();)<br>

[buffer(버퍼) = 데이터의 임시저장 공간]<br>
공백, 엔터를 사용시 getchar를 사이에 넣어야 함 <br> ->\n도 데이터로 인식하기 때문
```
{
      i = getchar();
      putchar(i); // a저장

      j = getchar();
      putchar(j); // \\n 저장

        k = getchar();
        putchar(k); // b저장

}
```

getch,putch = 엔터를 치지 않아도 메모리에 전송<br>
getch는 에코 X<br>( 에코 = 입력한 값이 화면에 나오는것 )<br>

gets,puts = 공백을 포함해서 입출력
<br>
<br>
<br>


# 연산자 1

2+3 -> 연산자 = + / 피연산자 = 2,3

1. ### 산술연산자(+ - * / %  -) <br>
   -> 부호변경<br>
- int 연산자 char = int 형 ( 아스키코드)
- int 연산자 float = float 형
- char 연산자 char = 아스키코드에 의한 문자
- char 연산자 float = float 형 (아스키코드)<br><br>

2. ### 대입연산자(=    += -= *= /= %=) <br>
   -> 오른쪽 값을 왼쪽에 저장해라<br><br>
4. ### 복합대입 연산자(+= -= *= /= %=)<br><br>

4. ### 논리연산자(&& || !)=(and or not)<br>
    ㄴ>조건식(비교식)들의 연산<br>
    ㄴ>조건에 의해서 결과가 참 혹은 거짓으로 나오는 식<br>
true =1 // false = 0<br><br>

5. ### 비교연산자(== < > <= >= !=)<br>
* a<b ( 앞이 주어 뒤가 목적어 ) = a가 b보다 작다<br>
    * = -> 대입연산자<br>
    * == -> 비교연산자<br><br>

6. ### 증감연산자(++ --) <br>
   = 증가연산자 + 감소 연산자<br>
- 변수명++; = 전위형 -> 연산을 가장 먼저!<br>
- ++변수명; = 후위형 -> 연산을 가장 나중에!
<br>
<br>
<br>

# 연산자 2

1. ### 비트연산자 <br>
   = 비트단위로 연산을 한다<br>
ㄴ 비트 : 데이터의 *최소* 단위<br>
ㄴ 바이트 : 메모리의 *기본* 단위 ( 1bit * 8 = 1byte)

 * ### 비트 논리 연산자

<AND = & > <OR = |> <XOR = ^> <NOT = ~><br>
1) true : 1, false : 0<br>
2) a&b = 두 비트가 모두 1일때만 결과가 1<br>
3) a|b = 두 비트 중 하나라도 1이라면 결과가 1<br>
4) a^b = 두 비트가 서로 다르면 1, 같으면 0<br>
5) (a=1,b=1 -> a^b=0 // a=1,b=0 -> a^b=1)<br>
6) ~a = 비트가 1->0, 0->1<br>


|AND연산|OR연산|XOR연산|NOT연산|
|:--:|:--:|:--:|:--:|
|a=0001|a=0001|a=0001|a=0001|
|b=0010	|b=0010|b=0010|
|0000=0|0011=3|1100=3|1110=14|


> * NOT연산<br>* 컴퓨터는 음수를 저장할 수 없음 <br>*  음수표현, 부호비트사용<br> * 최상위 비트 =0 =음수//=1=양수
<br> 
    (실제로 컴퓨터는 64bit 사용 -> 코드로 썼을때 14가 나오지 않음)<br>*
2의 4bit 단위 표현법을 구한 다음에, ~(-2) = 1 이 나오면<br>  ~(1)=-2>	2+(-2)=0 -> 0010 + 1110 = 0000
~(1110) = 0001s

진법변환

* 10진수 -> 2진수
   몫이 1이 나올때까지 2로 나누기
   나머지를 아래에서부터 차례대로
   7=111	4=100

* 2진수 -> 10진수
    각 비트의 자릿수를 적는다(0 1 2 4 8 16 32...)
   비트 자리가 1인 것만 필터링
   110=6	111=7



 * ### 비트 쉬프트 연산자
|왼쪽|오른쪽|
|:--:|:--:|
|<<|>>|
|a<<4|a>>4|
|X2 효과|/2 효과|
<br>

2. ### 콤마 연산자(,)
     연결<br><br>

3. ### 삼항 연산자(? :)<br><br>

4. ### 형변환 연산자
     (자료형)변수명;
     (int) a=3.5 -> 3
<br> <br> 
5. ### 크기 연산자
     sizeof(자료형 또는 변수명);
     바이트 단위 확인 가능

     최우선 연산자		( )<br>
     단항 연산자		|| ~ + --<br>
     산술 연산자		* / + -<br>
     쉬프트 연산자		<< >><br>
     관계(비교)연산자		<= = ><br>
     (논리)연산자		& <br>
     삼항연산자		? :<br>
     대입연산자		=<br>
<br>
<br>
<br>


# 조건문 1

조건문 = (제어문의 종류) 1.조건문 2.반복문<br>
 -조건의 결과에 따라 실행한 문장을 결정<br><br>
제어문 = 프로그램의 흐름을 제어하는 문법!<br>

#if (조건문)

- 항상 결과값이 참 혹은 거짓으로 나오는 식<br>
- else = **바로 위에오는** if 문의 조건식을 부정<br>
- if문의 조건식을 부정? == 'if문의 조건식이 거짓일때' 라는 전제조건 포함
<br>
<br>
<br>


# 조건문 2

#switch 문<br>
switch(변수 or 수식) <- 조건식 X<br>
  ```
   { case 값1:		    //case 와 값 사이에 꼭 띄어쓰기	
                 
     변수 == 값1;    //콜론 주의 ->세미콜론 X
          break;		//비교를 중단
     case 값2:
         변수 == 값2;
     break;
     default:
         모든 case 값이 아닐때;	
         }
 ```

- 변수는 1개의 값만 가질 수 있다.
- 수식의 결과도 1개의 결과값만 나온다
<br>
<br>
<br>


# 반복문 1
while, do-while, while(1)
```
while(조건식){
   조건식이 참일때 반복할 명령;
   증감식	}
```
```
do{	조건식이 참일때 반복할 명령;
   증감식	}
while(조건식);

- do-while 문은 조건이 거짓이여도 1번은 실행!!!
```
```
무한반복문
- while 문의 조건식이 항상 참->반복은 멈추지 않고 계속ㄱㄱ

whie(1){
   조건식이 참일때 반복할 명령;
   증감식	}
   ```
<br>
<br>
<br>


# 반복문 2

```
for(초기식;비교식;증감식){
   명령;	}
```
-초기식 : 변수생성
-비교식 : 반복할 조건을 변수의 값으로 비교

실행순서?<br>
----첫번째 반복

1. 초기식
2. 비교식
3. 비교식이 참이라면? -> 명령실행<br>
비교식이 거짓이라면 ? -> 반복종료
4. 증감식<br>

-----두번째 반복 ->초기식 실행X
5. 비교식
6. 비교식이 참이라면? -> 명령실행<br>
비교식이 거짓이라면 ? -> 반복종료
7. 증감식<br>

-----세번째 반복 ..


pow(밑수,지수)<br>
ex) pow(2,3) = 2의 3제곱
<br>
<br>
<br>


# 기타 제어문


#break 문 -> 중단

- 가장 근접한 반복문을 빠져나간다!

#continue 문 -> 계속

- 시작부분 이동

#goto 문 -> 점프

- goto 문을 만나면 문번호로 제어를 옮김
- 프로그램의 가독성을 떨어뜨리고, 오류를 유발할 수 있으므로 사용 권장 X
```
goto 문번호;

    문번호 :
    명령;
```
#return 문 -> 반환

- 함수의 실행을 끝내는 기능
<br>
<br>
<br>


# 중첩반복문

-반복문을 반복할 필요가 생길때 사용
```
for(int i=0;i<**횟수**;i++)
```
```
별찍기

for(int j=0; j<행갯수; j++){
           for(int i=0; i<열갯수: i++){
                 printf("*");
                      }
       printf("\n");
}
```
행 : 5개<br>
열 : 1-2-3-4-5개
<br>
<br>
<br>


# 함수 1

- 나열된 여러명령들의 묶음 -> 묶여진 명령들이 순서가 있다<br>
- 자주 사용하는 여러명령들을 묶어서 이름을 호출해 사용
함수는 main함수 위에!!<br>

매개변수 = 함수의 호출부에서 전달하는 값을 구현부에서 받아와 저장하기 위한 변수<br>
```
<구현부>
   리턴값 함수명(매개변수){
	명령 1;
	명령 2;
   }
<호출부>
   함수명(값);
```
return 값 = 함수 내 모든 명령이 실행된 후, 결과값을 값으로 지정
<br>
<br>
<br>


# 함수 2

변수 -> 값을 저장하는 공간<br>
변수의 생명주기 = 변수가 메모리에 존재하는 시간<br>
( 지역변수 , 전역변수 , 정적번수 , 매개변수 , 외부변수 )

1. 전역변수
    - 전체 소스코드에서 사용가능
2. 지역변수
    - 코드 블록 내에서만 사용가능
3. 정적변수 (static 자료형 변수명;)
    - 함수가 종결되어도 계속 사용가능
4. 매개변수
    - 함수 블록 내에서만 사용가능
5. 외부변수 (external 자료형 변수명;)
    - 호출방법 : external 함수의 프로토타입
    - 다른 소스파일에 선언

스택영역 : 지역변수, 매개변수 -> 함수의 호출부터 종료까지 	(프리영역)<br>
힙영역 : 동적메모리 할당(프리영역)<br>
데이터영역 : 정적변수, 전역변수 -> 프로그램이 실행되고 종료될때까지
<br>
<br>
<br>


# 배열 1

-> **같은 자료형**을 가진 여러개의 **나열**된 변수의 묶음

1. 모든 요소는 같은 자료형
2. 모든 요소는 물리적으로도 나열
정수형 배열일 경우 각 요소는 4byte 차이만큼 떨어져서 저장이 된다.
3. 배열의 이름 = 배열의 첫번째 요소의 주소 의미<br>
( 배열명 == &배열[0])

```
자료형 배열명[배열 크기]; 

- 배열의 각 요소에 접근하기 위해선 배열명[번호] 로 접근 
      -> 0번부터
```


초기화 = 선언한 후 바로 값을 대입하는 것<br>
               한꺼번에 삽입 X -> 하나씩<br>
              
 ```
1 자료형 배열명[배열크기]={초기값1,초기값2..};
2 자료형 배열명[ ]={초기값1,초기값2..};
3 자료형 배열명[배열크기]={초기값1, ,초기값3..};
```

#문자열 = 문자형의 배열

<br>
<br>
<br>


# 배열 2

#2차원 배열

- 배열의 각 요소가 **1차원 배열**인 배열<br>
- 자료형 배열명[행][열]<br>
={ {값1,값2,값3},{값4,값5,값6}, ... };

#3차원 배열

- 배열의 각 요소가 **2차원 배열**인 배열<br>
- 자료형 배열명[면][행][열]<br>
={ { {값1,값2,값3},{값4,값5,값6}, ... }, { {값1,값2,값3},{값4,값5,값6}, ... } };<br>
    * 3차원 배열의 한 면의 크기 == 2차원 배열의 크기<br>
    * 3차원 배열의 한 행의 크기 == 1차원 배열의 크기<br>

#문자열의 배열<br>
문자열 : 문자형의 배열 : 1차원 배열<br>
문자열의 배열 : 2차원 배열
<br>
<br>
<br>


# 포인터

= 변수의 주소를 저장하는 공간 ( 자료형 * 포인터변수명; )

- 변수를 사용할때 **변수의 주소로 접근**하기 위해서<br>
< 변수명 앞에 붙은 & = 변수의 주소 >

포인터변수는 모두 4byte 크기를 가진다<br>
포인터 = 주소값 = 양의 정수형 숫자 값<br>

포인터에 변수의 주소 저장<br>
```
        자료형 * 포인터변수명 = &변수명;
 ```
포인터로 변수의 값에 접근 = 간접참조연산자<br>
       -> * 포인터명
<br>
<br>
<br>


# 포인터 연산

-포인터 생성방법<br>
> 자료형 * 포인터명;<br>

-포인터에 변수주소를 저장<br>
> 포인터명 = &변수명;<br>

-포인터로 변수값 접근<br>
> 포인터명;<br>

- 가능한 것

     ptr=ptr+1;<br>
     ptr=ptr+2;<br>
     ptr++;<br>
     ++ptr;<br>
     Ptr--;<br>
     --ptr;<br><br>
포인터가 저장한 값 +1 을 하면, 자료형만큼 크기 증가<br>(int의 경우 4byte 이므로 4증가)<br>
포인터가 저장한 값 -1 을 하면, 자료형만큼 크기 감소<br>(int의 경우 4byte 이므로 4감소)<br>
= byte 크기만큼 증가

ptr++; = 주소값 증가<br>
*ptr++; = 값을 반환하고, 주소값 증가<br>
(*ptr)++; = 변수의 값 증가
<br>
<br>
<br>


# 포인터와 배열의 관계

- 배열의 이름 = 배열의 시작요소의 주소! <br>-> 포인터에 저장 및 포인터 연산 가능!

    #간접참조연산자<br>
    = (* 포인터명)<br>
    = 포인터가 저장하고 있는 주소값으로 가서 해당 주소의 값을 가져오는 것<br>

- 배열의 이름으로 포인터 연산하기<br>
배열명으로 가능한 포인터 연산	: 덧셈, 뺄셈, 간접참조연산자(*)<br>
배열명으로 불가능한 포인터 연산	: 증감연산자(++, --) <br>-> 배열명은 주소값 변경이 불가!

    포인터 + 1 = 포인터의 주소에 +1을 해라<br>
    포인터 + + = 포인터의 주소를 포인터의 주소 +1값으로 변경해라<br>

- 배열의 첨자 : [ ]<br>
= 배열의 크기, 배열의 요소 접근시 안에 위치를 지정해 접근 가능<br>

1. a+0 : 현재위치
2. a+1 : 현재위치 +1
3. (a+1) : 현재 위치 +1 위치의 요소 값 접근

배열명[0] == *(배열명+0)
<br>
<br>
<br>


# 포인터와 함수의 관계

swap( ) 실행 <br>-> swap( )함수 내 x, y의 값은 변경되었으나 실제 main에서 x, y의 값은 변경 X<br>
-> 함수의 호출이 Call By Value(CBV)(=**값에 의한 호출**) 이기 때문

값이 복사되어 전달되면 Call By Value (값에 의한 호출) - 일반변수 사용<br>
변수의 주소가 전달되면 Call By Adress (주소에 의한 호출) - 포인터변수 사용
<br>
<br>
<br>


# 이중 포인터

**포인터의 메모리 주소**를 저장하는 포인터 ( 자료형 ** 변수명; )<br>
     ex) 	int num=10;<br>
                int *pnum=#<br>
                int **dbpnum=&pnum;<br>

- 배열의 이름은 이중포인터의 값으로 들어갈 수 없다!

     ex)      int ar[5] = {1,2,3,4,5};<br>
                dbpar = &ar (X)
<br>
<br>
<br>


# 포인터 배열과 배열 포인터

#포인터 배열 ( 자료형 * 포인터배열명 [크기] ; )<br>

- 배열의 요소가 포인터인 배열<br>

#배열 포인터 ( 자료형 (* 배열포인터명) [크기] ; )<br>

- 배열의 주소를 저장하는 포인터<br>
<br>
<br>
<br>

# 동적 메모리 할당 1

= 프로그램의 실행 도중, 메모리를 할당 받는 것<br>

필요한 이유?<br>
ㄴ정적메모리의 크기는 중간에 바꿀수 X <br>-> 크기가 바뀌면 코드를 수정해야함

1. #include <stdlib.h>
2. malloc ( ) 함수<br>
: 괄호 안에 적은 숫자 byte 크기 만큼 메모리 할당
-> 할당 받은 메모리의 시작 주소를 반환하는 함수
3. 저장할 포인터 생성<br>
    - malloc ( ) 함수가 할당 받은 메모리의 시작주소를 반환하므로<br>
    시작 주소를 저장할 포인터를 생성해 포인터에 주소 저장

    - sizeof(자료형) = 해당 자료형의 바이트 크기 반환
   -  free(포인터) = 동적 할당 받은 메모리 해제

스택영역 = 함수가 실행되고 종료될때까지 ( 매개변수, 지역변수)<br>
데이터영역 = 프로그램이 실행되고 종료될때까지( 전역변수, 정적변수)<br>
힙영역 = malloc로 할당받고 free로 반환
<br>
<br>
<br>

# 동적 메모리 할당 2

#동적 메모리 할당으로 2차원 배열 사용<br>
-2차원 배열 : 배열의 각 요소가 배열

1. #include <stdlib.h>
2. malloc( ) 함수 사용
3. 할당 받을 메모리를 저장할 **이중 포인터** 생성
4. 1차원 배열을 생성할 **단일 포인터** 생성
5. 단일 포인터와 이중 포인터 모두 free

= 각 배열을 저장할 수 있는 공간 생성을 위해/ 이중 포인터로 공간 할당<br>
      -> 각각의 배열요소인 포인터에 동적 할당으로 공간 생성!
<br>
<br>
<br>


# 구조체

= **여러** 자료형의 변수들을 모아놓은 변수들의 집합 <br>#배열 = **같은** 자료형

- 필드 : 데이터를 분류하는 속성
- 레코드 : 속성으로 구분된 값
```
    struct 구조체명 {
    자료형 변수명1;
    자료형 변수명2;
    }
    struct 구조체명 구조체변수명 ;
```
초기화 방법<br> : struct 구조체명 변수명={초기값1, 초기값2, 초기값3} ;
<br>
<br>
<br>


# 구조체 배열

- 구조체 배열의 정의 <br>-> 배열의 요소가 구조체 변수
구조체명 배열명 [배열크기] ;
<br>
<br>
<br>

# 구조체 포인터

* 구조체 변수의 주소를 저장하는 변수<br>
> [ struct 구조체명 * 구조체포인터명 ; ]

* 포인터로 변수 값을 접근하는 방법?<br>
-> 간접참조연산자 : *

* 구조체 포인터가 접근해야 할 값<br> = 구조체 변수 내 생성한 변수 (필드)<br>
[ 구조체포인터명->구조체내변수]

* 구조체 포인터에 동적 할당 방법<br>
> struct 구조체명 * 구조체포인터명;

* 구조체포인터 = (구조체포인터명)malloc(할당 받을 크기);
<br>
<br>
<br>


# 구조체 내 구조체

-구조체 필드 생성 시 구조체 변수 생성<br>
-구조체 내 구조체 변수 접근 방법? -<br>> 단계적으로 접근
```
1)

struct 구조체명 {
        자료형 변수명1 ;
        자료형 변수명2 ;
    struct 구조체명 구조체변수명;
};
```
```
2)

구조체 내에서만 사용할 구조체라면, 구조체 내에서 구조체 구현 가능!

struct 구조체명1{
     자료형 변수명1 ;
     자료형 변수명2 ;
struct 구조체명2 {
      자료형 변수명3 ;
      자료형 변수명4 ;

    }구조체변수명;
};
```
```
- 구조체 초기화 방법

struct 구조체명 구조체변수명 = {값1, 값2, 값3..} ;
```
```
- 구조체 내 구조체 초기화 방법

struct 구조체명 구조체변수명={
    .멤버=값1,
    .멤버=값2,
        {.멤버=값3,
        .멤버=값4}..} ;
    struct 구조체명 구조체변수명 = {값1, 값2, {값3, 값4}..} ;
```
typedef 구조체 재정의<br>
사용이유?<br>
->구조체 사용시 struct 키워드 붙이는 것이 불편하기 때문에<br>
```
1)
typedef struct 구조체명{
    자료형 변수명;
    자료형 변수명;
};
  구조체명 구조체변수명;
```
```
2)
typedef struct 구조체명{
    자료형 변수명;
    자료형 변수명;
  }   구조체별명;
  구조체명 구조체변수명;
```
<br>
<br>
<br>



# 구조체와 비트 필드

- 비트 = 데이터의 최소단위 ( 1bit X 4 = 1byte )<br>
               ㄴ데이터 : 010101011100...<br>

```
- 생성방법

struct 구조체명 {
    자료형 변수명 : 필요한비트수;
    자료형 변수명 : 필요한비트수;
    자료형 변수명 : 필요한비트수;
    ....
};
```
<br>
<br>
<br>



# 공용체

- **하나의 메모리**를 여러개의 변수가 공용하는 구조<br>
-공용체의 크기는 가장 큰 byte의 크기를 따라간다<br>

특징

1. 공용체 내 생성한 변수들은 하나의 메모리를 공용한다.
2. 공용체 내 변수들은 서로 다른 자료형을 가질 수 있다.

```
    union 공용체명{
        자료형 변수명1;
        자료형 변수명2;
      ....
    };
        union 공용체명 공용체변수명;
```
<br>
<br>
<br>



# 열거형

-변수가 가질 수 있는 데이터의 값들을 선언하여 사용하는 것<br>

특징

1. 열거형으로 선언된 변수는 기호상수만 사용 가능
2. 가독성을 위해 사용하는 것으로 상수만 사용 가능
3. 변수와의 구분을 위해 이름은 대분자로 지정

>  enum 열거형변수명 { 기호상수1, 기호상수2, 기호상수3 ....} ;

기호상수 = 변하지 않는 상수를 기호(변수)로 나타내는 것<br>
> enum { 기호상수1 = 값1, 기호상수2 = 값2 ...}
